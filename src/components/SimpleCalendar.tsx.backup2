import { useState, useEffect } from 'react';
import { open } from '@tauri-apps/plugin-dialog';
import { stat, readTextFile, writeTextFile, exists, BaseDirectory } from '@tauri-apps/plugin-fs';
import { openPath } from '@tauri-apps/plugin-opener';

interface TimeSlot {
  date: string; // ISO date string (YYYY-MM-DD)
  day: number; // 0-6 for Sun-Sat
  hour: number; // 0-23
  title?: string;
  labels?: string[];
  files?: FileLink[];
  notes?: string;
  startMinute?: number; // Actual start minute for the session
  endMinute?: number; // Actual end minute for the session
  startHour?: number; // Actual start hour for the session
  endHour?: number; // Actual end hour for the session
  column?: number; // Which column (0 or 1) this session belongs to
}

interface SessionEdit {
  day: number;
  startHour: number;
  startMinute: number;
  endHour: number;
  endMinute: number;
  column: number; // Which column (0 or 1) this session belongs to
}

interface FileLink {
  id: string;
  name: string;
  path: string;
  size: number;
  type: 'file' | 'folder';
}

interface LabelColor {
  name: string;
  color: string;
}

export default function SimpleCalendar() {
  const [slots, setSlots] = useState<TimeSlot[]>([]);
  const [dragStart, setDragStart] = useState<{ day: number; hour: number; minute: number; col: number } | null>(null);
  const [dragEnd, setDragEnd] = useState<{ day: number; hour: number; minute: number; col: number } | null>(null);
  const [editingSession, setEditingSession] = useState<SessionEdit | null>(null);
  const [sessionTitle, setSessionTitle] = useState('');
  const [sessionLabels, setSessionLabels] = useState<string[]>([]);
  const [newLabel, setNewLabel] = useState('');
  const [allLabels, setAllLabels] = useState<string[]>(['Work', 'Personal', 'Meeting', 'Project']); // Sample labels
  const [labelColors, setLabelColors] = useState<LabelColor[]>([
    { name: 'Work', color: '#3B82F6' },
    { name: 'Personal', color: '#10B981' },
    { name: 'Meeting', color: '#F59E0B' },
    { name: 'Project', color: '#8B5CF6' },
  ]);
  const [sessionFiles, setSessionFiles] = useState<FileLink[]>([]);
  const [sessionNotes, setSessionNotes] = useState('');
  const [weekOffset, setWeekOffset] = useState(0); // 0 = current week, -1 = previous week, +1 = next week
  const [isInitialLoad, setIsInitialLoad] = useState(true);
  const [editingLabelColor, setEditingLabelColor] = useState<string | null>(null);

  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const hours = Array.from({ length: 24 }, (_, i) => i);

  // Get current date info
  const today = new Date();

  // Load sessions from localStorage on mount
  useEffect(() => {
    try {
      const savedData = localStorage.getItem('day-tracker-sessions');
      const migrationDone = localStorage.getItem('day-tracker-migration-v2');

      // One-time migration: clear old UTC-formatted data
      if (savedData && !migrationDone) {
        console.log('Migrating from UTC dates to local dates - clearing old data');
        localStorage.removeItem('day-tracker-sessions');
        localStorage.setItem('day-tracker-migration-v2', 'done');
      } else if (savedData) {
        const data = JSON.parse(savedData);
        setSlots(data.slots || []);
        setAllLabels(data.allLabels || ['Work', 'Personal', 'Meeting', 'Project']);
        setLabelColors(data.labelColors || [
          { name: 'Work', color: '#3B82F6' },
          { name: 'Personal', color: '#10B981' },
          { name: 'Meeting', color: '#F59E0B' },
          { name: 'Project', color: '#8B5CF6' },
        ]);
      }
    } catch (error) {
      console.error('Error loading sessions:', error);
    }
    setIsInitialLoad(false);
  }, []);

  // Save sessions to localStorage whenever they change (but not on initial load)
  useEffect(() => {
    if (isInitialLoad) return;

    try {
      const data = {
        slots,
        allLabels,
        labelColors,
      };
      localStorage.setItem('day-tracker-sessions', JSON.stringify(data));
      console.log('Saved to localStorage:', data);
    } catch (error) {
      console.error('Error saving sessions:', error);
    }
  }, [slots, allLabels, labelColors, isInitialLoad]);

  // Helper to get local date string (YYYY-MM-DD) without timezone conversion
  const getLocalDateString = (date: Date): string => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  // Calculate dates for the week starting from Sunday
  const getWeekDates = () => {
    const today = new Date();
    const curr = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    curr.setDate(curr.getDate() + (weekOffset * 7)); // Apply week offset
    const dayOfWeek = curr.getDay(); // 0 = Sunday, 6 = Saturday
    const firstDayOfWeek = new Date(curr);
    firstDayOfWeek.setDate(curr.getDate() - dayOfWeek); // Go back to Sunday

    return days.map((_, i) => {
      const date = new Date(firstDayOfWeek);
      date.setDate(firstDayOfWeek.getDate() + i);
      return date;
    });
  };

  const weekDates = getWeekDates();

  // Get the month and year from the first date of the current week
  const currentMonth = weekDates[0].toLocaleDateString('en-US', { month: 'long' });
  const currentYear = weekDates[0].getFullYear();

  const goToPreviousWeek = () => {
    setWeekOffset(weekOffset - 1);
  };

  const goToNextWeek = () => {
    setWeekOffset(weekOffset + 1);
  };

  const goToToday = () => {
    setWeekOffset(0);
  };

  // Get current time info for the red line
  const now = new Date();
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  const currentTimePosition = currentHour * 60 + currentMinute; // Minutes from midnight

  const getMinuteFromMouseEvent = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const cellHeight = 60; // Height of each hour cell in pixels
    const minute = Math.floor((y / cellHeight) * 60);
    return Math.max(0, Math.min(59, minute));
  };

  const handleCellMouseDown = (day: number, hour: number, col: number, row: number, e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();

    // Calculate minute based on row (4 rows = 15 min each)
    const minute = row * 15;
    console.log('Cell mouse down:', day, hour, minute, 'col:', col, 'row:', row);

    // Check if there's a session in THIS specific cell (column + time range)
    const dateString = getLocalDateString(weekDates[day]);
    const cellStartMinutes = hour * 60 + minute;
    const cellEndMinutes = cellStartMinutes + 15; // Each cell is 15 minutes

    console.log('Checking for session at:', { dateString, day, hour, minute, col, cellStartMinutes, cellEndMinutes });
    console.log('All slots:', slots);

    const existingSessionInCell = slots.find(s => {
      if (s.date !== dateString || s.day !== day || s.column !== col) return false;

      // If this slot has detailed time info, check for overlap
      if (s.startHour !== undefined && s.startMinute !== undefined &&
          s.endHour !== undefined && s.endMinute !== undefined) {
        const sessionStartMinutes = s.startHour * 60 + s.startMinute;
        const sessionEndMinutes = s.endHour * 60 + s.endMinute;

        const overlaps = cellStartMinutes < sessionEndMinutes && cellEndMinutes > sessionStartMinutes;
        console.log('Checking slot with times:', s, 'overlaps:', overlaps);
        return overlaps;
      }

      // Fallback: if no detailed time info, just check if the hour matches
      const overlaps = s.hour === hour;
      console.log('Checking slot without times (hour-based):', s, 'overlaps:', overlaps);
      return overlaps;
    });

    console.log('Found session:', existingSessionInCell);

    // If clicking on existing session in this specific cell, open edit mode
    if (existingSessionInCell) {
      setEditingSession({
        day: day,
        startHour: existingSessionInCell.startHour ?? hour,
        startMinute: existingSessionInCell.startMinute ?? 0,
        endHour: existingSessionInCell.endHour ?? (hour + 1),
        endMinute: existingSessionInCell.endMinute ?? 0,
        column: existingSessionInCell.column ?? 0,
      });
      setSessionTitle(existingSessionInCell.title || '');
      setSessionLabels(existingSessionInCell.labels || []);
      setSessionFiles(existingSessionInCell.files || []);
      setSessionNotes(existingSessionInCell.notes || '');
      return;
    }

    // Otherwise start creating new session - include column info
    setDragStart({ day, hour, minute, col });
    setDragEnd({ day, hour, minute, col });
  };

  const handleCellMouseEnter = (day: number, hour: number, col: number, row: number, e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();

    if (dragStart && dragStart.day === day && dragStart.col === col) {
      const minute = row * 15;
      console.log('Cell mouse enter:', day, hour, minute, 'col:', col, 'row:', row);
      setDragEnd({ day, hour, minute, col });
    }
  };

  const handleCellMouseUp = (day: number, hour: number, col: number, row: number, e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();

    const minute = row * 15;
    console.log('Cell mouse up:', day, hour, minute, 'col:', col, 'row:', row);

    if (dragStart && dragStart.col === col) {
      // Calculate start and end times (add 15 min to end to include the full cell)
      const startTotalMinutes = dragStart.hour * 60 + dragStart.minute;
      const endTotalMinutes = hour * 60 + minute + 15;

      const isReverse = endTotalMinutes < startTotalMinutes;
      const minTotalMinutes = isReverse ? endTotalMinutes - 15 : startTotalMinutes;
      const maxTotalMinutes = isReverse ? startTotalMinutes + 15 : endTotalMinutes;

      const startHour = Math.floor(minTotalMinutes / 60);
      const startMinute = minTotalMinutes % 60;
      const endHour = Math.floor(maxTotalMinutes / 60);
      const endMinute = maxTotalMinutes % 60;

      // Open the edit panel
      setEditingSession({
        day: dragStart.day,
        startHour,
        startMinute,
        endHour,
        endMinute,
        column: dragStart.col,
      });
      setSessionTitle('');
      setSessionLabels([]);
      setSessionFiles([]);
      setSessionNotes('');
      setNewLabel('');

      // Clear the drag state
      setDragStart(null);
      setDragEnd(null);
    }
  };

  const handleSessionClick = (dayIdx: number, hour: number) => {
    const slot = getSlotAtPosition(dayIdx, hour);
    if (!slot) return;

    // Populate the edit form with stored time values if available
    setEditingSession({
      day: dayIdx,
      startHour: slot.startHour ?? hour,
      startMinute: slot.startMinute ?? 0,
      endHour: slot.endHour ?? (hour + 1),
      endMinute: slot.endMinute ?? 0,
      column: slot.column ?? 0,
    });
    setSessionTitle(slot.title || '');
    setSessionLabels(slot.labels || []);
    setSessionFiles(slot.files || []);
    setSessionNotes(slot.notes || '');
  };

  const handleSaveSession = () => {
    if (editingSession && sessionTitle.trim()) {
      const sessionDate = weekDates[editingSession.day];
      const dateString = getLocalDateString(sessionDate); // YYYY-MM-DD

      // Remove old slots for this session (if editing)
      const filteredSlots = slots.filter(s => {
        if (s.date === dateString && s.day === editingSession.day && s.column === editingSession.column) {
          // Check if this slot is part of the session being edited (same column, same title)
          return s.title !== sessionTitle.trim();
        }
        return true;
      });

      const newSlots: TimeSlot[] = [];
      // Calculate which hours this session spans
      let startHourForSlots = editingSession.startHour;
      let endHourForSlots = editingSession.endHour;

      // If end minute is 0, we don't need to include the end hour
      if (editingSession.endMinute === 0 && editingSession.endHour > editingSession.startHour) {
        endHourForSlots = editingSession.endHour;
      } else {
        endHourForSlots = editingSession.endHour + 1;
      }

      for (let h = startHourForSlots; h < endHourForSlots; h++) {
        newSlots.push({
          date: dateString,
          day: editingSession.day,
          hour: h,
          title: sessionTitle.trim(),
          labels: sessionLabels.length > 0 ? sessionLabels : undefined,
          files: sessionFiles.length > 0 ? sessionFiles : undefined,
          notes: sessionNotes.trim() || undefined,
          startHour: editingSession.startHour,
          startMinute: editingSession.startMinute,
          endHour: editingSession.endHour,
          endMinute: editingSession.endMinute,
          column: editingSession.column,
        });
      }
      setSlots([...filteredSlots, ...newSlots]);
      setEditingSession(null);
      setSessionTitle('');
      setSessionLabels([]);
      setSessionFiles([]);
      setSessionNotes('');
    }
  };

  const handleDeleteSession = () => {
    if (editingSession && sessionTitle.trim()) {
      const sessionDate = weekDates[editingSession.day];
      const dateString = getLocalDateString(sessionDate);

      // Remove all slots for this session (in the same column)
      const filteredSlots = slots.filter(s => {
        if (s.date === dateString && s.day === editingSession.day && s.column === editingSession.column && s.title === sessionTitle.trim()) {
          return false;
        }
        return true;
      });

      setSlots(filteredSlots);
      setEditingSession(null);
      setSessionTitle('');
      setSessionLabels([]);
      setSessionFiles([]);
      setSessionNotes('');
    }
  };

  const handleCancelSession = () => {
    setEditingSession(null);
    setSessionTitle('');
    setSessionLabels([]);
    setSessionFiles([]);
    setSessionNotes('');
    setNewLabel('');
  };

  const handleAddLabel = () => {
    if (newLabel.trim() && !sessionLabels.includes(newLabel.trim())) {
      setSessionLabels([...sessionLabels, newLabel.trim()]);
      if (!allLabels.includes(newLabel.trim())) {
        setAllLabels([...allLabels, newLabel.trim()]);
        // Add a default color for new labels
        const defaultColors = ['#EF4444', '#F97316', '#84CC16', '#06B6D4', '#6366F1', '#EC4899'];
        const newColor = defaultColors[labelColors.length % defaultColors.length];
        setLabelColors([...labelColors, { name: newLabel.trim(), color: newColor }]);
      }
      setNewLabel('');
    }
  };

  const handleRemoveLabel = (label: string) => {
    setSessionLabels(sessionLabels.filter(l => l !== label));
  };

  const getLabelColor = (labelName: string): string => {
    const labelColor = labelColors.find(lc => lc.name === labelName);
    return labelColor ? labelColor.color : '#6B7280';
  };

  const getSlotColor = (slot: TimeSlot | undefined): string => {
    if (!slot || !slot.labels || slot.labels.length === 0) {
      return '#34D399'; // Default green
    }
    // Use the first label's color
    return getLabelColor(slot.labels[0]);
  };

  const handleUpdateLabelColor = (labelName: string, newColor: string) => {
    setLabelColors(labelColors.map(lc =>
      lc.name === labelName ? { ...lc, color: newColor } : lc
    ));
  };

  const handleAddFiles = async () => {
    try {
      const selected = await open({
        multiple: true,
        directory: false,
      });

      if (selected) {
        const paths = Array.isArray(selected) ? selected : [selected];
        const newFiles: FileLink[] = [];

        for (const path of paths) {
          try {
            const metadata = await stat(path);
            newFiles.push({
              id: crypto.randomUUID(),
              name: path.split('/').pop() || path,
              path,
              size: metadata.size,
              type: 'file',
            });
          } catch (error) {
            console.error('Error reading file metadata:', error);
          }
        }

        setSessionFiles([...sessionFiles, ...newFiles]);
      }
    } catch (error) {
      console.error('Error selecting files:', error);
    }
  };

  const handleAddFolder = async () => {
    try {
      const selected = await open({
        multiple: false,
        directory: true,
      });

      if (selected && typeof selected === 'string') {
        setSessionFiles([
          ...sessionFiles,
          {
            id: crypto.randomUUID(),
            name: selected.split('/').pop() || selected,
            path: selected,
            size: 0,
            type: 'folder',
          },
        ]);
      }
    } catch (error) {
      console.error('Error selecting folder:', error);
    }
  };

  const handleRemoveFile = (fileId: string) => {
    setSessionFiles(sessionFiles.filter(f => f.id !== fileId));
  };

  const handleOpenFile = async (filePath: string) => {
    try {
      await openPath(filePath);
    } catch (error) {
      console.error('Error opening file/folder:', error);
    }
  };

  const formatFileSize = (bytes: number) => {
    if (bytes === 0) return 'Folder';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
  };

  const formatTime = (hour: number, minute: number) => {
    const isPM = hour >= 12;
    const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
    const displayMinute = minute.toString().padStart(2, '0');
    const period = isPM ? 'PM' : 'AM';
    return `${displayHour}:${displayMinute} ${period}`;
  };

  const isDragging = (day: number, hour: number) => {
    if (!dragStart || !dragEnd || dragStart.day !== day) return false;
    const startMinutes = dragStart.hour * 60 + dragStart.minute;
    const endMinutes = dragEnd.hour * 60 + dragEnd.minute;
    const min = Math.min(startMinutes, endMinutes);
    const max = Math.max(startMinutes, endMinutes);
    const hourStartMinutes = hour * 60;
    const hourEndMinutes = (hour + 1) * 60 - 1;
    return hourStartMinutes <= max && hourEndMinutes >= min;
  };

  const getSlotAtPosition = (day: number, hour: number) => {
    const dateString = getLocalDateString(weekDates[day]);
    return slots.find(s => s.date === dateString && s.hour === hour);
  };

  const getOverlappingSlotsAtTime = (day: number, hour: number, minute: number): TimeSlot[] => {
    const dateString = getLocalDateString(weekDates[day]);
    const currentTimeMinutes = hour * 60 + minute;

    // Get all unique sessions (by title) for this day
    const daySessions = slots.filter(s => s.date === dateString && s.day === day);
    const uniqueSessions = new Map<string, TimeSlot>();

    daySessions.forEach(slot => {
      if (slot.title && !uniqueSessions.has(slot.title)) {
        uniqueSessions.set(slot.title, slot);
      }
    });

    // Find sessions that overlap with the current time
    const overlapping: TimeSlot[] = [];
    uniqueSessions.forEach(session => {
      if (session.startHour !== undefined && session.startMinute !== undefined &&
          session.endHour !== undefined && session.endMinute !== undefined) {
        const sessionStartMinutes = session.startHour * 60 + session.startMinute;
        const sessionEndMinutes = session.endHour * 60 + session.endMinute;

        if (currentTimeMinutes >= sessionStartMinutes && currentTimeMinutes < sessionEndMinutes) {
          overlapping.push(session);
        }
      }
    });

    return overlapping.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
  };

  // Get all sessions that overlap with any part of an hour cell
  const getOverlappingSlotsInHour = (day: number, hour: number): TimeSlot[] => {
    const dateString = getLocalDateString(weekDates[day]);
    const hourStartMinutes = hour * 60;
    const hourEndMinutes = (hour + 1) * 60;

    // Get all unique sessions (by title) for this day
    const daySessions = slots.filter(s => s.date === dateString && s.day === day);
    const uniqueSessions = new Map<string, TimeSlot>();

    daySessions.forEach(slot => {
      if (slot.title && !uniqueSessions.has(slot.title)) {
        uniqueSessions.set(slot.title, slot);
      }
    });

    // Find sessions that overlap with any part of this hour
    const overlapping: TimeSlot[] = [];
    uniqueSessions.forEach(session => {
      if (session.startHour !== undefined && session.startMinute !== undefined &&
          session.endHour !== undefined && session.endMinute !== undefined) {
        const sessionStartMinutes = session.startHour * 60 + session.startMinute;
        const sessionEndMinutes = session.endHour * 60 + session.endMinute;

        // Check if session overlaps with this hour at all
        if (sessionStartMinutes < hourEndMinutes && sessionEndMinutes > hourStartMinutes) {
          overlapping.push(session);
        }
      }
    });

    return overlapping.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
  };

  return (
    <div className="flex h-screen bg-white">
      {/* Left side - Calendar */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Header with month/year and navigation */}
        <div className="px-6 py-4 bg-white" style={{ borderBottom: '1px solid #F3F4F6' }}>
          <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold text-gray-900">{currentMonth} {currentYear}</h1>
            <div className="flex items-center gap-3">
              <button onClick={goToPreviousWeek} className="text-2xl text-gray-600 hover:text-gray-900">‹</button>
              <button onClick={goToToday} className="px-3 py-1 text-sm border border-gray-300 rounded-lg hover:bg-gray-50">Today</button>
              <button onClick={goToNextWeek} className="text-2xl text-gray-600 hover:text-gray-900">›</button>
              <button
                onClick={() => setSlots([])}
                className="ml-4 px-3 py-1 text-xs text-red-600 hover:bg-red-50 rounded-lg"
              >
                Clear All
              </button>
            </div>
          </div>
        </div>

        <div className="flex-1 overflow-auto">
          <div>
            {/* Day Headers */}
            <div style={{ display: 'flex', backgroundColor: 'white', borderBottom: '1px solid #F3F4F6' }}>
              <div style={{ width: '128px', flexShrink: 0 }}></div>
              {days.map((day, i) => {
                const date = weekDates[i];
                const isToday = date.toDateString() === today.toDateString();
                return (
                  <div
                    key={i}
                    style={{
                      flex: 1,
                      minWidth: '120px',
                      padding: '0.5rem',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '0.5rem',
                      borderRight: '1px solid #F3F4F6',
                      boxSizing: 'border-box'
                    }}
                  >
                    <span className="text-xs text-gray-500 font-medium">
                      {day.slice(0, 3)}
                    </span>
                    {isToday ? (
                      <div className="w-7 h-7 flex items-center justify-center bg-red-500 text-white rounded-full text-sm font-semibold">
                        {date.getDate()}
                      </div>
                    ) : (
                      <span className="text-xs text-gray-500 font-medium">
                        {date.getDate()}
                      </span>
                    )}
                  </div>
                );
              })}
            </div>

        {/* Grid */}
        {hours.map((hour) => {
          const isPM = hour >= 12;
          const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
          const period = isPM ? 'PM' : 'AM';

          return (
            <div key={hour} style={{ display: 'flex' }}>
              {/* Time label */}
              <div style={{
                width: '128px',
                flexShrink: 0,
                backgroundColor: 'white',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                height: '60px'
              }}>
                <span className="text-sm text-gray-700 font-medium inline-block text-right" style={{ width: '16px' }}>{displayHour}</span>
                <span className="text-xs text-gray-400 ml-1">{period}</span>
              </div>

              {/* Day cells */}
              {days.map((day, dayIdx) => {
                const slot = getSlotAtPosition(dayIdx, hour); // Keep for click handler compatibility
                const isDrag = isDragging(dayIdx, hour);
                const isTodayColumn = weekDates[dayIdx].toDateString() === today.toDateString();

                // Get all overlapping sessions in this hour
                const overlappingSessions = getOverlappingSlotsInHour(dayIdx, hour);
                const totalOverlapping = overlappingSessions.length;

                // Check if current time line should be in this cell
                const shouldShowTimeLine = isTodayColumn && currentHour === hour;
                const timeLinePosition = shouldShowTimeLine ? (currentMinute / 60) * 60 : null; // Position in pixels from top of cell

                return (
                  <div
                    key={dayIdx}
                    style={{
                      position: 'relative',
                      flex: 1,
                      minWidth: '120px',
                      height: '60px',
                      borderRight: '1px solid #F3F4F6',
                      borderBottom: '2px solid #F3F4F6',
                      boxSizing: 'border-box',
                      display: 'grid',
                      gridTemplateColumns: 'repeat(2, 1fr)',
                      gridTemplateRows: 'repeat(4, 1fr)',
                      gap: '1px',
                      backgroundColor: '#F3F4F6',
                      padding: '1px',
                      gridAutoFlow: 'column'
                    }}
                  >
                    {/* 8 grid cells: 2 columns x 4 rows */}
                    {([0, 1] as const).map((col) =>
                      ([0, 1, 2, 3] as const).map((row) => {
                        // Check if this specific cell is in the drag selection
                        const cellMinute = row * 15;
                        const isCellInDrag = dragStart && dragEnd &&
                          dragStart.day === dayIdx &&
                          dragStart.col === col &&
                          dragEnd.col === col &&
                          (() => {
                            const startMin = Math.min(dragStart.hour * 60 + dragStart.minute, dragEnd.hour * 60 + dragEnd.minute);
                            const endMin = Math.max(dragStart.hour * 60 + dragStart.minute, dragEnd.hour * 60 + dragEnd.minute) + 15;
                            const cellStart = hour * 60 + cellMinute;
                            const cellEnd = cellStart + 15;
                            return cellStart < endMin && cellEnd > startMin;
                          })();

                        return (
                          <div
                            key={`${col}-${row}`}
                            className="cursor-pointer select-none"
                            onMouseDown={(e) => handleCellMouseDown(dayIdx, hour, col, row, e)}
                            onMouseEnter={(e) => handleCellMouseEnter(dayIdx, hour, col, row, e)}
                            onMouseUp={(e) => handleCellMouseUp(dayIdx, hour, col, row, e)}
                            style={{
                              backgroundColor: isCellInDrag ? '#DBEAFE' : '#FFFFFF',
                              transition: 'background-color 0.1s',
                            }}
                          />
                        );
                      })
                    )}

                    {/* Overlay container for sessions */}
                    <div style={{
                      position: 'absolute',
                      top: 0,
                      left: 0,
                      right: 0,
                      bottom: 0,
                      pointerEvents: 'none'
                    }}
                  >
                    {/* Render all overlapping sessions */}
                    {!isDrag && overlappingSessions.map((slot, sessionIndex) => {
                      // Calculate position for this session based on its column
                      const sessionColumn = slot.column ?? 0;
                      const sessionWidth = 50; // Always 50% (one column)
                      const sessionLeft = sessionColumn * 50; // 0% for column 0, 50% for column 1

                      // Check if this is the first hour of this session
                      const prevHourSessions = hour > 0 ? getOverlappingSlotsInHour(dayIdx, hour - 1) : [];
                      const isFirstHourOfSession = !prevHourSessions.some(s => s.title === slot.title);

                      // Calculate partial coloring for this cell
                      let partialColorTop = 0;
                      let partialColorHeight = 100;

                      if (slot.startHour !== undefined && slot.startMinute !== undefined &&
                          slot.endHour !== undefined && slot.endMinute !== undefined) {
                        const cellStartMinutes = hour * 60;
                        const cellEndMinutes = (hour + 1) * 60;
                        const sessionStartMinutes = slot.startHour * 60 + slot.startMinute;
                        const sessionEndMinutes = slot.endHour * 60 + slot.endMinute;

                        const colorStartMinutes = Math.max(cellStartMinutes, sessionStartMinutes);
                        const colorEndMinutes = Math.min(cellEndMinutes, sessionEndMinutes);

                        if (colorStartMinutes < colorEndMinutes) {
                          partialColorTop = ((colorStartMinutes - cellStartMinutes) / 60) * 100;
                          partialColorHeight = ((colorEndMinutes - colorStartMinutes) / 60) * 100;
                        }
                      }

                      // Calculate border radius
                      const nextHourSessions = hour < 23 ? getOverlappingSlotsInHour(dayIdx, hour + 1) : [];
                      const isLastHourOfSession = !nextHourSessions.some(s => s.title === slot.title);

                      let borderRadius = '0';
                      if (isFirstHourOfSession && isLastHourOfSession) {
                        borderRadius = '8px';
                      } else if (isFirstHourOfSession) {
                        borderRadius = '8px 8px 0 0';
                      } else if (isLastHourOfSession) {
                        borderRadius = '0 0 8px 8px';
                      }

                      return (
                        <div key={slot.title || sessionIndex}>
                          {/* Partial color overlay */}
                          <div
                            style={{
                              position: 'absolute',
                              top: `${partialColorTop}%`,
                              left: `${sessionLeft}%`,
                              width: `${sessionWidth}%`,
                              height: `${partialColorHeight}%`,
                              backgroundColor: getSlotColor(slot) + 'CC',
                              borderRadius: borderRadius,
                              zIndex: 1,
                              pointerEvents: 'none'
                            }}
                          />
                          {/* Session content */}
                          {isFirstHourOfSession && (
                            <div
                              className="text-xs"
                              style={{
                                position: 'absolute',
                                left: `${sessionLeft}%`,
                                width: `${sessionWidth}%`,
                                top: `${partialColorTop}%`,
                                height: `${partialColorHeight}%`,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                zIndex: 2,
                                padding: '0.5rem'
                              }}
                            >
                              <div className="truncate font-semibold text-white text-center w-full">{slot.title}</div>
                            </div>
                          )}
                        </div>
                      );
                    })}
                    {/* Current time indicator line */}
                    {shouldShowTimeLine && timeLinePosition !== null && (
                      <div
                        style={{
                          position: 'absolute',
                          top: `${timeLinePosition}px`,
                          left: 0,
                          right: 0,
                          height: '2px',
                          backgroundColor: '#EF4444',
                          zIndex: 100,
                          pointerEvents: 'none'
                        }}
                      >
                        <div style={{
                          position: 'absolute',
                          left: 0,
                          top: '-4px',
                          width: '8px',
                          height: '8px',
                          borderRadius: '50%',
                          backgroundColor: '#EF4444'
                        }} />
                      </div>
                    )}
                    </div>
                  </div>
                );
              })}
            </div>
          );
        })}
          </div>
        </div>
      </div>

      {/* Right side - Session Form Panel */}
      {editingSession && (
        <div className="w-96 bg-white flex-shrink-0 flex flex-col h-full" style={{ borderLeft: '1px solid #F3F4F6' }}>
          <div className="pt-8 pr-8 pb-8 pl-8 flex-1 overflow-y-auto">
            <h2 className="text-2xl font-semibold text-gray-900 mb-2">
              {slots.some(s => s.date === getLocalDateString(weekDates[editingSession.day]) && s.day === editingSession.day && s.title === sessionTitle) ? 'Edit Session' : 'New Session'}
            </h2>

            {/* Day info */}
            <div className="mb-8 text-sm text-gray-500">
              {days[editingSession.day]}, {weekDates[editingSession.day].toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
            </div>

            {/* Title */}
            <div className="mb-10">
              <label className="block text-sm font-semibold text-gray-700 mb-4">
                Title
              </label>
              <input
                type="text"
                value={sessionTitle}
                onChange={(e) => setSessionTitle(e.target.value)}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400 focus:border-blue-400 bg-gray-50"
                placeholder="What did you work on?"
                autoFocus
              />
            </div>

            {/* Time Range */}
            <div className="mb-10">
              <label className="block text-sm font-semibold text-gray-700 mb-4">
                Time
              </label>
              <div className="flex gap-3 items-center text-sm">
                <input
                  type="number"
                  min="0"
                  max="23"
                  value={editingSession.startHour}
                  onChange={(e) => setEditingSession({ ...editingSession, startHour: parseInt(e.target.value) || 0 })}
                  className="w-14 px-2 py-1.5 border border-gray-200 rounded-lg text-center bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-400"
                />
                <span className="text-gray-400">:</span>
                <input
                  type="number"
                  min="0"
                  max="59"
                  step="15"
                  value={editingSession.startMinute}
                  onChange={(e) => setEditingSession({ ...editingSession, startMinute: parseInt(e.target.value) || 0 })}
                  className="w-14 px-2 py-1.5 border border-gray-200 rounded-lg text-center bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-400"
                />
                <span className="text-gray-400">to</span>
                <input
                  type="number"
                  min="0"
                  max="23"
                  value={editingSession.endHour}
                  onChange={(e) => setEditingSession({ ...editingSession, endHour: parseInt(e.target.value) || 0 })}
                  className="w-14 px-2 py-1.5 border border-gray-200 rounded-lg text-center bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-400"
                />
                <span className="text-gray-400">:</span>
                <input
                  type="number"
                  min="0"
                  max="59"
                  step="15"
                  value={editingSession.endMinute}
                  onChange={(e) => setEditingSession({ ...editingSession, endMinute: parseInt(e.target.value) || 0 })}
                  className="w-14 px-2 py-1.5 border border-gray-200 rounded-lg text-center bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-400"
                />
              </div>
            </div>

            {/* Labels */}
            <div className="mb-10">
              <label className="block text-sm font-semibold text-gray-700 mb-4">
                Labels
              </label>

              {/* Existing labels selection */}
              <div className="flex flex-wrap gap-2 mb-5">
                {allLabels.map((label) => {
                  const labelColor = getLabelColor(label);
                  const isSelected = sessionLabels.includes(label);
                  return (
                    <div key={label} className="flex items-center gap-1">
                      <button
                        onClick={() => {
                          if (isSelected) {
                            handleRemoveLabel(label);
                          } else {
                            setSessionLabels([...sessionLabels, label]);
                          }
                        }}
                        className="px-3 py-1 text-xs rounded-full transition-colors font-medium"
                        style={{
                          backgroundColor: isSelected ? labelColor : labelColor + '20',
                          color: isSelected ? '#FFFFFF' : labelColor,
                          border: `2px solid ${labelColor}`
                        }}
                      >
                        {label}
                      </button>
                      <input
                        type="color"
                        value={labelColor}
                        onChange={(e) => handleUpdateLabelColor(label, e.target.value)}
                        className="w-6 h-6 rounded cursor-pointer"
                        title="Change color"
                      />
                    </div>
                  );
                })}
              </div>

              {/* Add new label */}
              <div className="flex gap-2">
                <input
                  type="text"
                  value={newLabel}
                  onChange={(e) => setNewLabel(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleAddLabel()}
                  className="flex-1 px-3 py-1.5 text-sm border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400 bg-gray-50"
                  placeholder="New label"
                />
                <button
                  onClick={handleAddLabel}
                  className="px-3 py-1.5 text-sm bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
                >
                  Add
                </button>
              </div>
            </div>

            {/* Files */}
            <div className="mb-6">
              <label className="block text-sm font-semibold text-gray-700 mb-3">
                Linked Files
              </label>
              <div className="flex gap-2 mb-3">
                <button
                  onClick={handleAddFiles}
                  className="flex-1 px-3 py-2 text-sm bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                >
                  Add Files
                </button>
                <button
                  onClick={handleAddFolder}
                  className="flex-1 px-3 py-2 text-sm bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors"
                >
                  Add Folder
                </button>
              </div>

              {sessionFiles.length > 0 && (
                <div className="mt-3 space-y-2">
                  {sessionFiles.map((file) => (
                    <div
                      key={file.id}
                      className="flex items-center justify-between p-2.5 bg-gray-50 rounded-lg text-xs border border-gray-100 hover:bg-gray-100 transition-colors"
                    >
                      <div
                        className="flex-1 min-w-0 cursor-pointer"
                        onClick={() => handleOpenFile(file.path)}
                      >
                        <div className="font-medium truncate text-gray-800 hover:text-blue-600">{file.name}</div>
                        <div className="text-gray-500 truncate text-[10px]">{file.path}</div>
                        <div className="text-gray-400">{formatFileSize(file.size)}</div>
                      </div>
                      <div className="flex items-center gap-2 ml-2">
                        <button
                          onClick={() => handleOpenFile(file.path)}
                          className="px-2 py-1 text-[10px] bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
                          title="Open file/folder"
                        >
                          Open
                        </button>
                        <button
                          onClick={() => handleRemoveFile(file.id)}
                          className="text-gray-400 hover:text-red-500 text-lg"
                          title="Remove"
                        >
                          ×
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Notes */}
            <div className="mb-8">
              <label className="block text-sm font-semibold text-gray-700 mb-3">
                Notes
              </label>
              <textarea
                value={sessionNotes}
                onChange={(e) => setSessionNotes(e.target.value)}
                className="w-full px-3 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-1 focus:ring-blue-400 focus:border-blue-400 bg-gray-50 resize-none"
                rows={4}
                placeholder="Additional notes..."
              />
            </div>

            {/* Actions */}
            <div className="flex justify-between items-center gap-3 pt-4 border-t border-gray-200">
              {/* Check if we're editing an existing session */}
              {slots.some(s => s.date === getLocalDateString(weekDates[editingSession.day]) && s.day === editingSession.day && s.title === sessionTitle) && (
                <button
                  onClick={handleDeleteSession}
                  className="px-4 py-2 text-sm bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors"
                >
                  Delete
                </button>
              )}
              <div className="flex gap-3 ml-auto">
                <button
                  onClick={handleCancelSession}
                  className="px-4 py-2 text-sm border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveSession}
                  className="px-4 py-2 text-sm bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled={!sessionTitle.trim()}
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
